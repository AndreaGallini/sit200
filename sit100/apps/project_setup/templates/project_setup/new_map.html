{% extends "layout.html" %}
{% block title %}
Mappa di progetto
{% endblock %}
{% block content %}
{% load static %}
{% csrf_token %}

<head>
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <link rel="stylesheet" href="{% static 'fontawesome/css/all.min.css' %}">
    <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
    <script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>

</head>
<div class="overflow-x-hidden relative full_h_100">
    <!-- Container per le notifiche personalizzate -->
    <div id="notification-container" class="fixed top-[110px] right-4 z-[10000] space-y-2"></div>
    
    <div class="flex top_map" id="div1">
        <div class="flex">
            <div class="left">
                <h1 class="h3">Seleziona la <br>location</h1>
            </div>
            <div class="vertical_line"></div>
            <div class="center">
                <div class="flex pt-[5px]">
                    <div class="inner_form_lat_long">
                        <input type="text" id="manual-lat" placeholder="Latitudine" class="input_form_1_project input"
                            maxlength="10">
                        <input type="text" id="manual-lon" placeholder="Longitudine" class="input_form_1_project input"
                            maxlength="10">
                    </div>
                    <button onclick="addMarkerManually()">
                        <img src="{% static 'image/icons/search_icon.svg' %}" alt="" class="hover:fill-yellow_light_1">
                    </button>
                </div>
                <div class="flex">
                    <div class="pt-2 pb-2 inner_form_lat_long">
                        <input type="text" id="autocomplete" placeholder="Inserisci l'indirizzo"
                            class="input address_input_map" maxlength="100">
                    </div>
                    <button onclick="searchLocation()" id="searchButton">
                        <img src="{% static 'image/icons/search_icon.svg' %}" alt="" class="hover:fill-yellow_light_1">
                    </button>
                </div>
            </div>
        </div>
        <div class="flex justify-self-end items-center right z-[100]">
            <a href="#" class="btn btn-primary h-[65px] w-[130px] next_btn_disable z-[100]" id="next_arrow_1"
                onclick="showNextDiv(),disableClickInteraction()">
                Avanti
                <img src="{% static 'image/icons/arrowr.png' %}" alt="" class="h-[15px]  z-[100]" id="arrow1">
            </a>
        </div>
    </div>
    <div class="hidden top_map" id="div2">
        <div class="flex">
            <div class="left">
                <h1 class="h3">Area di<br>interesse</h1>
            </div>
            <div class="vertical_line"></div>
            <div class="center pt-[5px] px-[44px] flex flex-col gap-y-3">
                <div class="flex gap-x-4 items-center" id="activateDrawingButton" onclick="initializePolygonDrawing()">
                    <svg class="hover:cursor-pointer [&>rect]:hover:fill-[#FFE182] [&>path]:hover:fill-[#EFB90B]"
                        width="35" height="35" viewBox="0 0 35 35" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <rect class="transition-colors duration-300" width="35" height="35" rx="5" fill="#EFB90B" />
                        <path class="transition-colors duration-300"
                            d="M19.3025 14.875L20.125 15.6975L12.18 23.625H11.375V22.82L19.3025 14.875ZM22.4525 9.625C22.2337 9.625 22.0062 9.7125 21.84 9.87875L20.2388 11.48L23.52 14.7613L25.1212 13.16C25.4625 12.8187 25.4625 12.25 25.1212 11.9262L23.0738 9.87875C22.8988 9.70375 22.68 9.625 22.4525 9.625ZM19.3025 12.4162L9.625 22.0938V25.375H12.9062L22.5837 15.6975L19.3025 12.4162Z"
                            fill="#1C1E20" />
                    </svg>
                    <p class="p">Disegna poligono</p>
                </div>
                <div class="flex gap-x-4 items-center" onclick="promptSavePolygon()">
                    <svg class="hover:cursor-pointer [&>rect]:hover:fill-[#FFE182] [&>path]:hover:fill-[#EFB90B]"
                        width="35" height="35" viewBox="0 0 35 35" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <rect class="transition-colors duration-300" width="35" height="35" rx="5" fill="#EFB90B" />
                        <path class="transition-colors duration-300"
                            d="M20.1711 14.9213L11.4214 14.9988L11.3904 11.4989L20.1401 11.4214M17.6237 23.6942C16.9275 23.7004 16.2574 23.4297 15.7608 22.9418C15.2642 22.4539 14.9817 21.7887 14.9755 21.0926C14.9694 20.3964 15.24 19.7263 15.7279 19.2297C16.2158 18.733 16.881 18.4506 17.5772 18.4444C18.2734 18.4382 18.9435 18.7089 19.4401 19.1968C19.9367 19.6847 20.2192 20.3499 20.2253 21.0461C20.2315 21.7422 19.9609 22.4123 19.473 22.9089C18.9851 23.4056 18.3199 23.688 17.6237 23.6942ZM21.8745 9.656L11.3749 9.749C10.4037 9.7576 9.63197 10.552 9.6405 11.5144L9.74899 23.7639C9.75311 24.2281 9.94141 24.6715 10.2725 24.9968C10.6036 25.3221 11.0503 25.5025 11.5144 25.4984L23.7639 25.3899C24.2281 25.3858 24.6715 25.1975 24.9968 24.8664C25.3221 24.5353 25.5025 24.0886 25.4984 23.6245L25.4054 13.1249L21.8745 9.656Z"
                            fill="#1C1E20" />
                    </svg>
                    <p class="p">Salva poligono</p>
                </div>
            </div>
            <div class="vertical_line"></div>
            <div class="grid grid-cols-3 gap-2 max-h-[500px] overflow-y-auto poligons p" id="polygons-list">
            </div>
        </div>
        <div class="flex gap-x-3 justify-self-end items-center right">
            <a href="#" class="btn btn-base h-[65px]" onclick="showPrevDiv(),enableClickInteraction()">
                <svg width="8" height="12" viewBox="0 0 8 12" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path
                        d="M7.41004 1.42L2.83003 6L7.41003 10.59L6.00003 12L3.48568e-05 6L6.00004 -1.23266e-07L7.41004 1.42Z"
                        fill="#EFB90B" />
                </svg>
                Indietro
            </a>
            <a href="#" class="btn btn-primary h-[65px] w-[130px] next_btn_disable" id="check">Termina<br>prima fase
                <svg width="8" height="12" viewBox="0 0 8 12" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M0 10.58L4.58 6L0 1.41L1.41 0L7.41 6L1.41 12L0 10.58Z" fill="#001522" />
                </svg>
            </a>
        </div>
    </div>

    <div class="inner_content_map">
        <div class="ext_map">
            <div id="map" class="relative map-container">

                <div id="popup_check" style="display: none;">
                    <div
                        class="flex flex-col justify-center items-center gap-y-5 popup-content rounded-md sfondo h-[300px] w-[500px] leading-4">
                        <h3 class="h3" style="line-height: 110%;">Sei sicuro di voler terminare<br>la prima fase?</h3>
                        <p class="p" style="line-height: 110%;">Una volta che procedi alla fase successiva<br>
                            non potrai pi√π modificare la posizione.</p>
                        <div class="flex gap-x-4 items-center">
                            <button onclick="closePopupCheck()" class="flex gap-x-3 items-center border_button_general">
                                <img src="{% static 'image/icons/x.svg'  %}" alt=""> Annulla
                            </button>
                            <button id="saveMap" onclick="handleSaveMap()"
                                class="flex gap-x-3 items-center text-primary-content button_general">
                                Conferma <img src="{% static 'image/icons/floppy.svg' %}" alt="">
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div id="reportBox" class="report_box">
            <div class="flex gap-[50px]">
                <p id="cords" class="p">Coordinate selezionate: <span id="coordinates"></span> <span
                        id="altitudeValue"></span></p>
            </div>
            <div>
                <p id="cords_cursor" class="p w-[420px]">Coordinate cursore: <span id="cursor-coordinates"></span></p>
            </div>
        </div>
    </div>
    <div id="loadingOverlay">
        <h3 class="h3" style="color: #fff;">Caricamento della seconda fase</h3>
        <p class="p" style="color: #fff;">Si prega di non ricaricare o uscire da questa pagina</p>
        <div class="loader"></div>
    </div>
</div>

<script>
    // Funzione per mostrare notifiche personalizzate
    // Funzione per mostrare una notifica, rimuovendo quelle esistenti
    function showNotification(message, type = 'error') {
        const container = document.getElementById('notification-container');
        if (!container) return;
        
        // Rimuovi tutte le notifiche esistenti
        const existingNotifications = container.querySelectorAll('.alert');
        existingNotifications.forEach(notification => notification.remove());
        
        const notification = document.createElement('div');
        notification.className = `alert alert-${type} shadow-lg max-w-md z-[9999]`;
        notification.innerHTML = `
            <svg xmlns="http://www.w3.org/2000/svg" class="w-6 h-6 stroke-current shrink-0" fill="none" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z" />
            </svg>
            <span>${message}</span>
            <button class="btn btn-sm btn-ghost" onclick="this.parentElement.remove()">
                <svg xmlns="http://www.w3.org/2000/svg" class="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                </svg>
            </button>
        `;
        
        container.appendChild(notification);
        
        // Rimuovi automaticamente dopo 5 secondi
        setTimeout(() => {
            if (notification.parentElement) {
                notification.remove();
            }
        }, 5000);
    }

    // Global variables
    let map;
    let markerMovementEnabled = true;
    let drawingManager;
    let activePolygon = null;
    let polygons = [];
    let maxpolygons = 4;
    let isDrawingActive = false;
    let coordinates_span = document.getElementById('coordinates');
    let def_coordinates = { lat: null, lng: null }
    let save_map_array = []
    let save_map = false
    let def_altitude = null
    window.marker = null;
    let def_address_formatted = null
    let def_address_not_formatted = null
    let addressComponents = {
        street: '',
        streetNumber: '',
        municipality: '',
        province: '',
        postalCode: '',
        country: ''
    };
    let full_address = null;
    // Parse subfields from Django template - ora lo facciamo nel DOMContentLoaded
    let availableSubfields = [];
    // Variabile per memorizzare la distanza tra marker e primo vertice del poligono (in metri)
    let distanzaMarkerPrimoVertice = null;
    let distanzaMaxPrimoVertice = 3000

    // Document Ready Handler
    document.addEventListener('DOMContentLoaded', function () {
        // Inizializza i subfield
        try {
            availableSubfields = JSON.parse('{{ subfields|escapejs }}');
            
            // Inizialmente disabilita il bottone "Termina prima fase"
            const finishButton = document.getElementById('check');
            finishButton.classList.add('next_btn_disable');
        } catch (e) {
            console.error("Error parsing subfields:", e);
        }

        if (typeof google === 'undefined') {
            loadGoogleMaps();
        } else {
            initMap();
        }

        // Add window resize handler to ensure map responds to viewport changes
        window.addEventListener('resize', function () {
            if (map) {
                google.maps.event.trigger(map, 'resize');
                // Re-center the map if marker exists
                if (window.marker && window.marker.position) {
                    map.setCenter(window.marker.position);
                }
            }
        });

        // Periodically check if map has loaded correctly
        setTimeout(checkMapRendering, 3000);
    });

    // Function to check if map has rendered properly
    function checkMapRendering() {
        if (!map) {
            console.warn("Map not initialized yet, will retry");
            setTimeout(checkMapRendering, 1000);
            return;
        }

        const mapDiv = document.getElementById('map');
        if (!mapDiv) return;

        // Check if map tiles are visible
        const mapTiles = mapDiv.querySelectorAll('.gm-style img');
        if (mapTiles.length < 4) {
            console.warn("Map tiles not fully loaded, triggering refresh");
            google.maps.event.trigger(map, 'resize');
            map.setZoom(map.getZoom());
        }

        // Check map container dimensions
        if (mapDiv.offsetWidth < 100 || mapDiv.offsetHeight < 100) {
            console.warn("Map container has insufficient dimensions, adjusting");
            mapDiv.style.width = "100%";
            mapDiv.style.height = "600px";
            setTimeout(() => {
                google.maps.event.trigger(map, 'resize');
            }, 200);
        }
    }

    // Google Maps API Loading
    function loadGoogleMaps() {
        const script = document.createElement('script');
        script.src = `https://maps.googleapis.com/maps/api/js?key=AIzaSyBEw-P1yBRr6z1Nd8fhuimIP4V-9W8I8XI&callback=initMap&libraries=places,drawing,geometry&v=weekly`;
        script.async = true;
        script.defer = true;


        // Add timeout to retry loading if needed
        let loadingTimeout = setTimeout(() => {
            console.warn('Google Maps API loading timeout, retrying...');
            if (!window.google || !window.google.maps) {
                document.head.removeChild(script);
                loadGoogleMaps();
            }
        }, 10000);
        if (!document.head.querySelector('script[src*="maps.googleapis.com"]')) {
            document.head.appendChild(script);
        }
    }

    // Map Initialization
    async function initMap() {
        try {
            const mapElement = document.getElementById("map");
            // Wait for libraries to be loaded
            const loadLibraries = async () => {
                try {
                    const mapsLibrary = await google.maps.importLibrary("maps");
                    const markerLibrary = await google.maps.importLibrary("marker");
                    return { Map: mapsLibrary.Map, AdvancedMarkerElement: markerLibrary.AdvancedMarkerElement };
                } catch (err) {
                    console.error("Error loading Google Maps libraries:", err);
                    throw err;
                }
            };
            const { Map, AdvancedMarkerElement } = await loadLibraries();
            // Initialize Autocomplete
            initializeAutocomplete(AdvancedMarkerElement);
            // Create map centered on Rome, Italy
            const romaCoordinates = { lat: 41.9028, lng: 12.4964 };
            map = new Map(mapElement, {
                center: romaCoordinates,
                zoom: 8,
                mapTypeId: "hybrid",
                gestureHandling: "greedy",
                mapId: "2ff2c4f18c383d0d",
                rotateControl: false,
                fullscreenControl: true,
                streetViewControl: false,
                zoomControl: true,
                mapTypeControl: true
            });
            // Add map load event to ensure proper rendering
            google.maps.event.addListenerOnce(map, 'idle', function () {
                // Trigger resize after short delay to ensure map fills container
                setTimeout(() => {
                    google.maps.event.trigger(map, 'resize');

                    // Ensure map controls are visible
                    ensureMapControlsVisible();
                }, 500);
            });
            // Setup cursor coordinates display
            map.addListener('mousemove', function (event) {
                const mousePosition = event.latLng;
                const cursorSpan = document.getElementById('cursor-coordinates');
                if (cursorSpan) {
                    cursorSpan.textContent = `Lat: ${mousePosition.lat().toFixed(5)}, Lon: ${mousePosition.lng().toFixed(5)}`;
                }
            });
            setupMapClickHandler(AdvancedMarkerElement);
        } catch (error) {
            // Attempt recovery
            setTimeout(() => {
                initMap();
            }, 3000);
        }
    }

    // Function to ensure map controls are visible
    function ensureMapControlsVisible() {
        if (!map) return;

        // Force map controls to be visible by manipulating their CSS
        setTimeout(() => {
            const mapElement = document.getElementById('map');
            if (!mapElement) return;

            // Find all map controls
            const controls = mapElement.querySelectorAll('.gm-control-active, .gm-style-mtc, .gm-fullscreen-control');

            // Ensure they're visible by setting their display and opacity
            controls.forEach(control => {
                control.style.display = 'block';
                control.style.opacity = '1';
                control.style.visibility = 'visible';
            });

            // If no controls found, try again after a delay
            if (controls.length === 0) {
                setTimeout(ensureMapControlsVisible, 1000);
            }

            // Adjust map type control specifically (hybrid/satellite/roadmap)
            const mapTypeControls = mapElement.querySelectorAll('.gm-style-mtc');
            mapTypeControls.forEach(control => {
                control.style.zIndex = '1000'; // Ensure it's on top
            });
        }, 1000);
    }

    // Autocomplete initialization
    function initializeAutocomplete(AdvancedMarkerElement) {
        const autocomplete = new google.maps.places.Autocomplete(
            document.getElementById('autocomplete'),
            {
                types: ['geocode'],
                componentRestrictions: { country: 'it' },
                fields: ['geometry', 'formatted_address']
            }
        );
        autocomplete.addListener('place_changed', () => {
            if (!markerMovementEnabled) return;
            const place = autocomplete.getPlace();
            if (!place.geometry) {
                showNotification("Indirizzo non valido");
                return;
            }
            const position = place.geometry.location;
            
            // Controlla se il marker √® stato aggiornato (cio√® se √® in Italia)
            const wasMarkerUpdated = updateMarkerPosition(position, AdvancedMarkerElement, place.formatted_address);
            
            // Se il marker non √® stato aggiornato (non √® in Italia), non procedere
            if (!wasMarkerUpdated) {
                return;
            }
            
            coordinates_span.textContent = `Latitude: ${position.lat().toFixed(5)}, Longitude: ${position.lng().toFixed(5)}`;
            document.getElementById('autocomplete').style.border = '';
            document.getElementById('next_arrow_1').classList.remove('next_btn_disable');
            
            addCoordinates(position.lat().toFixed(5), position.lng().toFixed(5));
        });
    }

    // Setup map click handler
    function setupMapClickHandler(AdvancedMarkerElement) {
        map.clickListener = map.addListener('click', function (event) {
            if (!markerMovementEnabled) return;
            const clickPosition = event.latLng;
            
            // Controlla se il marker √® stato aggiornato (cio√® se √® in Italia)
            const wasMarkerUpdated = updateMarkerPosition(clickPosition, AdvancedMarkerElement, "Selected location");
            
            // Se il marker non √® stato aggiornato (non √® in Italia), non procedere
            if (!wasMarkerUpdated) {
                return;
            }
            
            coordinates_span.textContent = `Latitude: ${clickPosition.lat().toFixed(5)}, Longitude: ${clickPosition.lng().toFixed(5)}`;
            document.getElementById('next_arrow_1').classList.remove('next_btn_disable');
            
            reverseGeocode(clickPosition.lat(), clickPosition.lng());
            addCoordinates(clickPosition.lat().toFixed(5), clickPosition.lng().toFixed(5));
        });
    }

    // Update marker position
    function updateMarkerPosition(position, AdvancedMarkerElement, title) {
        // Check if position is in Italy
        if (!checkIfMarkerInItaly(position.lat(), position.lng())) {
            // If not in Italy, don't update the marker
            return false;
        }
        
        if (window.marker) {
            window.marker.position = position;
        } else {
            window.marker = new AdvancedMarkerElement({
                position: position,
                map: map,
                title: title
            });
        }
        map.setCenter(position);
        def_coordinates = { lat: position.lat(), lng: position.lng() }
        
        return true; // Marker aggiornato con successo
    }

    // ELEVATION FUNCTIONS
    async function getElevation(lat, lng) {
        try {
            const elevationService = new google.maps.ElevationService();
            const request = {
                locations: [{ lat, lng }]
            };
            const response = await elevationService.getElevationForLocations(request);
            if (response && response.results && response.results.length > 0) {
                temp_alt = Math.floor(response.results[0].elevation)
                def_altitude = temp_alt
                return Math.floor(response.results[0].elevation);
            }
            return null;
        } catch (error) {
            console.error("Error retrieving elevation:", error);
            return null;
        }
    }

    // LOCATION FUNCTIONS
    function addMarkerManually() {
        const latInput = document.getElementById('manual-lat').value.replace(/,/g, '.');
        const lonInput = document.getElementById('manual-lon').value.replace(/,/g, '.');
        const lat = parseFloat(latInput);
        const lon = parseFloat(lonInput);

        if (isNaN(lat) || isNaN(lon)) {
            showNotification('Prego inserire coordinate valide');
            document.getElementById('manual-lat').style.border = '2px solid red';
            document.getElementById('manual-lon').style.border = '2px solid red';
            return;
        }

        // Controlla se le coordinate sono in Italia
        if (!checkIfMarkerInItaly(lat, lon)) {
            return;
        }

        const manualPosition = new google.maps.LatLng(lat, lon);

        if (window.marker) {
            window.marker.position = manualPosition;
        } else {
            window.marker = new google.maps.marker.AdvancedMarkerElement({
                position: manualPosition,
                map: map,
                title: "Manual position"
            });
        }

        map.setCenter(manualPosition);
        def_coordinates = { lat: manualPosition.lat(), lng: manualPosition.lng() }
        coordinates_span.textContent = `Latitude: ${manualPosition.lat().toFixed(5)}, Longitude: ${manualPosition.lng().toFixed(5)}`;
        document.getElementById('next_arrow_1').classList.remove('next_btn_disable');
        
        reverseGeocode(manualPosition.lat(), manualPosition.lng());

        // Reset input borders
        document.getElementById('manual-lat').style.border = '';
        document.getElementById('manual-lon').style.border = '';
    }

    function searchLocation() {
        const searchQuery = document.getElementById('autocomplete').value;
        if (!searchQuery) {
            showNotification('Inserire indirizzo da cercare');
            document.getElementById('autocomplete').style.border = '2px solid red';
            return;
        }

        const geocoder = new google.maps.Geocoder();

        geocoder.geocode({ 'address': searchQuery }, function (results, status) {
            if (status === google.maps.GeocoderStatus.OK) {
                if (results[0]) {
                    const position = results[0].geometry.location;
                    
                    // Controlla se la posizione √® in Italia
                    if (!checkIfMarkerInItaly(position.lat(), position.lng())) {
                        return;
                    }

                    if (window.marker) {
                        window.marker.position = position;
                    } else {
                        window.marker = new google.maps.marker.AdvancedMarkerElement({
                            position: position,
                            map: map,
                            title: searchQuery
                        });
                    }

                    map.setCenter(position);
                    def_coordinates = { lat: position.lat(), lng: position.lng() }
                    // Format and display coordinates
                    const lat = position.lat().toFixed(5);
                    const lng = position.lng().toFixed(5);
                    coordinates_span.textContent = `Latitude: ${lat}, Longitude: ${lng}`;
                    addCoordinates(lat, lng);
                    document.getElementById('autocomplete').style.border = '';

                    // Enable next button
                    document.getElementById('next_arrow_1').classList.remove('next_btn_disable');
                    
                } else {
                    showNotification('Nessun luogo trovato con questo indirizzo');
                }
            } else {
                showNotification('Geocoding fallito riprovare');
            }
        });
    }

    function addCoordinates(lat, lng) {
        const manualLatInput = document.getElementById('manual-lat');
        const manualLonInput = document.getElementById('manual-lon');
        if (manualLatInput) manualLatInput.value = lat;
        if (manualLonInput) manualLonInput.value = lng;
    }

    async function reverseGeocode(lat, lng) {
        const geocoder = new google.maps.Geocoder();
        const latlng = { lat: parseFloat(lat), lng: parseFloat(lng) };

        return new Promise((resolve, reject) => {
            geocoder.geocode({ 'location': latlng }, function (results, status) {
                if (status === google.maps.GeocoderStatus.OK) {
                    if (results[0]) {
                        const address = results[0].formatted_address;
                        full_address = address
                        document.getElementById('autocomplete').value = address;
                        document.getElementById('autocomplete').style.border = '';
                        // Extract address components for potential future use
                        for (const component of results[0].address_components) {
                            const types = component.types;
                            if (types.includes('route')) {
                                addressComponents.street = component.long_name;
                            } else if (types.includes('street_number')) {
                                addressComponents.streetNumber = component.long_name;
                            } else if (types.includes('locality')) {
                                addressComponents.locality = component.long_name;
                            } else if (types.includes('administrative_area_level_2')) {
                                addressComponents.province = component.short_name;
                            } else if (types.includes('postal_code')) {
                                addressComponents.postalCode = component.long_name;
                            } else if (types.includes('country')) {
                                addressComponents.country = component.long_name;
                            }else if (types.includes('administrative_area_level_3')){
                                addressComponents.municipality = component.long_name
                            }else if (types.includes('administrative_area_level_1')){
                                addressComponents.region = component.long_name
                            }
                        }
                        // Enable next button
                        document.getElementById('next_arrow_1').classList.remove('next_btn_disable');
                        
                        resolve();
                    } else {
                        reject('No address found');
                    }
                } else {
                    console.error('Reverse geocoding failed: ' + status);
                    reject('Geocoding failed');
                }
            });
        });
    }

    // NAVIGATION FUNCTIONS
    function showNextDiv() {
        const div1 = document.getElementById('div1');
        const div2 = document.getElementById('div2');
        

        // Add exit animation to first div
        div1.classList.add('slide-out-left');

        // After exit animation completes
        setTimeout(() => {
            div1.classList.remove('flex');
            div1.classList.add('hidden');
            div1.classList.remove('slide-out-left');

            // Show second div with entrance animation
            div2.classList.remove('hidden');
            div2.classList.add('flex');
            div2.classList.add('slide-in-left');

            // Remove animation class after completion
            setTimeout(() => {
                div2.classList.remove('slide-in-left');
            }, 200);
        }, 200);
    }

    function showPrevDiv() {
        const div1 = document.getElementById('div1');
        const div2 = document.getElementById('div2');

        // Add exit animation to second div
        div2.classList.add('slide-out-right');

        // After exit animation completes
        setTimeout(() => {
            div2.classList.remove('flex');
            div2.classList.add('hidden');
            div2.classList.remove('slide-out-right');

            // Show first div with entrance animation
            div1.classList.remove('hidden');
            div1.classList.add('flex');
            div1.classList.add('slide-in-right');

            // Remove animation class after completion
            setTimeout(() => {
                div1.classList.remove('slide-in-right');
            }, 200);
        }, 200);
    }

    // POLYGON DRAWING FUNCTIONS
    function initializePolygonDrawing() {
        // Check if all subfields are used
        const usedSubfields = getUsedSubfields();
        
        if (usedSubfields.length >= availableSubfields.length) {
            
            showNotification('Hai gi√† assegnato tutti i sottocampi disponibili. Non puoi disegnare altri poligoni.');
            return;
        }
        

        // Toggle drawing mode if manager exists
        if (drawingManager) {
            if (isDrawingActive) {
                drawingManager.setDrawingMode(null);
                document.getElementById("activateDrawingButton").classList.remove("active_draw");
                isDrawingActive = false;
            } else {
                drawingManager.setDrawingMode(google.maps.drawing.OverlayType.POLYGON);
                document.getElementById("activateDrawingButton").classList.add("active_draw");
                isDrawingActive = true;
            }
            return;
        }

        // Initialize new drawing manager
        drawingManager = new google.maps.drawing.DrawingManager({
            drawingMode: google.maps.drawing.OverlayType.POLYGON,
            drawingControl: false,
            polygonOptions: {
                editable: true,
                draggable: true,
                strokeColor: "#EFB90B",
                strokeWeight: 2,
                fillColor: "#FFE182",
                fillOpacity: 0.3
            }
        });

        drawingManager.setMap(map);
        document.getElementById("activateDrawingButton").classList.add("active_draw");
        isDrawingActive = true;

        // Handle polygon creation
        google.maps.event.addListener(drawingManager, 'polygoncomplete', function (polygon) {
            drawingManager.setDrawingMode(null);
            document.getElementById("activateDrawingButton").classList.remove("active_draw");
            isDrawingActive = false;

            // Controllo distanza tra marker e primo vertice del poligono
            if (window.marker && window.marker.position) {
                const path = polygon.getPath();
                if (path.getLength() > 0) {
                    const primoVertice = path.getAt(0);
                    const markerPosition = window.marker.position;
                    
                    // Calcola la distanza in metri usando l'API di Google Maps
                    distanzaMarkerPrimoVertice = google.maps.geometry.spherical.computeDistanceBetween(
                        markerPosition, 
                        primoVertice
                    );
                    
                    
                    // Controllo se la distanza √® superiore a 3km
                    if (distanzaMarkerPrimoVertice > distanzaMaxPrimoVertice) {
                        showNotification(`Attenzione: La distanza tra il marker e il primo vertice del poligono √® di ${(distanzaMarkerPrimoVertice / 1000).toFixed(2)} km, che supera il limite di 3 km. Il poligono verr√† rimosso.`)
                        // Rimuovi il poligono dalla mappa
                        polygon.setMap(null);
                        activePolygon = null;
                        distanzaMarkerPrimoVertice = null;
                        return;
                    }
                }
            }

            // Controllo distanza dai poligoni esistenti (se ce ne sono gi√†)
            if (polygons.length > 0) {
                let distanzaMinimaPoligoni = Infinity;
                let poligonoVicino = null;
                
                // Trova la distanza minima da tutti i poligoni esistenti
                for (let i = 0; i < polygons.length; i++) {
                    const distanza = calcolaDistanzaMinimaTraPoligoni(polygon, polygons[i].reference);
                    if (distanza < distanzaMinimaPoligoni) {
                        distanzaMinimaPoligoni = distanza;
                        poligonoVicino = polygons[i];
                    }
                }
                
                
                // Controllo se la distanza √® superiore a 3 km
                if (distanzaMinimaPoligoni > distanzaMaxPrimoVertice) {
                    showNotification(`Attenzione: La distanza tra questo poligono e il poligono "${poligonoVicino.name}" √® di ${(distanzaMinimaPoligoni / 1000).toFixed(2)} km, che supera il limite di 3 km. Il poligono verr√† rimosso.`)
                    // Rimuovi il poligono dalla mappa
                    polygon.setMap(null);
                    activePolygon = null;
                    return;
                }
            }

            activePolygon = polygon;

            // Add listeners for polygon modification events
            google.maps.event.addListener(polygon.getPath(), 'set_at', function () { });
            google.maps.event.addListener(polygon.getPath(), 'insert_at', function () { });
        });
    }

    // POLYGON SAVE FUNCTIONS
    function promptSavePolygon() {
        if (!activePolygon) {
            showNotification('Non ci sono nuovi poligoni da salvare.')
            return;
        }

        const popupElement = document.getElementById('polygon-name-popup');
        if (!popupElement) {
            console.error("Element 'polygon-name-popup' not found");
            createPopupDynamically();
            return;
        }

        // Update available subfields before showing popup
        updateSubfieldSelect();

        // Check if there are still subfields available
        const subfieldSelect = document.getElementById('subfield-select');
        if (subfieldSelect.options.length <= 1) { // Only the default "Select" option
            showNotification('Hai gi√† assegnato tutti i sottocampi disponibili. Non puoi salvare altri poligoni.')
            return;
        }

        popupElement.style.display = 'flex';
        setupPolygonPopup();
    }

    function setupPolygonPopup() {
        const inputElement = document.getElementById('polygon-name-input');
        if (inputElement) {
            inputElement.value = '';
            setTimeout(() => inputElement.focus(), 100);
        }

        const saveButton = document.getElementById('save-polygon');
        if (saveButton) {
            saveButton.onclick = savePolygon;
        }
    }

    function createPopupDynamically() {
        const popupDiv = document.createElement('div');
        popupDiv.id = 'polygon-name-popup';
        popupDiv.className = 'polygon-save-modal';
        popupDiv.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.5); display: flex; justify-content: center; align-items: center; z-index: 998;';

        const contentDiv = document.createElement('div');
        contentDiv.className = 'flex flex-col justify-center items-center gap-y-5 popup-content rounded-md bg-base-100 h-[500px] w-[500px] absolute top-[50%] left-[50%] transform -translate-x-1/2 -translate-y-1/2';

        contentDiv.innerHTML = `
            <label for="polygon-name-input" class="h3">Salva poligono:</label>
            <input type="text" id="polygon-name-input" class="input input-primary mb-[30px] mt-[20px]"
                placeholder="Nome poligono (max 10 caratteri)" maxlength="10">
            <select id="subfield-select" class="select select-primary mb-[30px]">
                <option value="">Seleziona un sottocampo</option>
            </select>
            <div class="flex gap-x-4 items-center">
                <button id="cancel-polygon" class="flex gap-x-3 items-center border_button_general">Annulla</button>
                <button id="save-polygon" class="gap-x-3 items-center text-primary-content button_general">Salva</button>
            </div>
        `;

        popupDiv.appendChild(contentDiv);
        document.body.appendChild(popupDiv);

        document.getElementById('cancel-polygon').onclick = closePopup;
        document.getElementById('save-polygon').onclick = savePolygon;

        // Update subfield select after creating it
        setTimeout(() => {
            updateSubfieldSelect();
        }, 0);
    }

    function savePolygon() {
        const polygonName = document.getElementById('polygon-name-input').value;
        const selectedSubfield = document.getElementById('subfield-select').value;

        if (!polygonName) {
            showNotification('Inserisci il nome del poligono')
            return;
        }

        if (!selectedSubfield) {
            showNotification('Seleziona un sottocampo')
            return;
        }

        if (!activePolygon) {
            showNotification('Nessun poligono da salvare')
            closePopup();
            return;
        }

        // Extract polygon coordinates
        const path = activePolygon.getPath();
        const coordinates = [];
        for (let i = 0; i < path.getLength(); i++) {
            const point = path.getAt(i);
            coordinates.push({
                lat: point.lat(),
                lng: point.lng()
            });
        }

        // Make polygon non-editable and update styling
        activePolygon.setEditable(false);
        activePolygon.setDraggable(false);
        activePolygon.setOptions({
            strokeColor: "#FF4500",
            strokeWeight: 3,
            fillColor: "rgba(0,0,0,0)",
            clickable: false,
        });

        // Calculate polygon center for label positioning
        const polygonCenter = calculatePolygonCenter(activePolygon);
        
        // Create a custom label marker for the subfield name
        const labelMarker = createSubfieldLabel(polygonCenter, selectedSubfield);

        // Create polygon object for storage
        const polygonObject = {
            id: Date.now(),
            name: polygonName,
            subfield: selectedSubfield,
            coordinates: coordinates,
            reference: activePolygon,
            labelMarker: labelMarker
        };

        polygons.push(polygonObject);
        addPolygonToList(polygonObject);
        activePolygon = null;
        closePopup();

        // Check if all subfields have been used
        checkAllSubfieldsUsed();
    }

    // Function to check if all subfields have been used and update UI accordingly
    function checkAllSubfieldsUsed() {
        const usedSubfields = getUsedSubfields();
        
        const allSubfieldsUsed = usedSubfields.length === availableSubfields.length;
        const finishButton = document.getElementById('check');
        
        if (allSubfieldsUsed) {
            finishButton.classList.remove('next_btn_disable');
        } else {
            finishButton.classList.add('next_btn_disable');
        }
    }

    function closePopup() {
        const popupElement = document.getElementById('polygon-name-popup');
        if (popupElement) {
            popupElement.style.display = 'none';
            const inputElement = document.getElementById('polygon-name-input');
            if (inputElement) {
                inputElement.value = '';
            }
        }
    }

    // Add polygon to visible list
    function addPolygonToList(polygon) {
        const polygonsList = document.getElementById('polygons-list');

        const polygonElement = document.createElement('div');
        polygonElement.className = 'polygon-item';
        polygonElement.innerHTML = `
            <div class="flex gap-x-2 justify-between items-center w-full">
                <div class="flex flex-col">
                    <span>${polygon.name} - ${polygon.subfield}</span>
                </div>
                <button class="delete-polygon" title="Cancella poligono" data-id="${polygon.id}">
                    <i class="fa fa-trash"></i>
                </button>
            </div>
        `;

        polygonElement.querySelector('.delete-polygon').addEventListener('click', function () {
            deletePolygon(polygon.id);
        });

        polygonsList.appendChild(polygonElement);
    }

    // Delete a polygon
    function deletePolygon(polygonId) {
        const polygonIndex = polygons.findIndex(p => p.id === polygonId);
        if (polygonIndex !== -1) {
            // Remove polygon from map
            polygons[polygonIndex].reference.setMap(null);
            
            // Remove label marker from map if it exists
            if (polygons[polygonIndex].labelMarker) {
                polygons[polygonIndex].labelMarker.map = null;
            }

            // Remove from array
            polygons.splice(polygonIndex, 1);

            // Remove from UI
            const polygonsList = document.getElementById('polygons-list');
            const items = polygonsList.querySelectorAll('.polygon-item');
            items.forEach(item => {
                const deleteBtn = item.querySelector('.delete-polygon');
                if (deleteBtn && deleteBtn.getAttribute('data-id') == polygonId) {
                    item.remove();
                }
            });

            // Re-enable drawing button if there are still available subfields
            const usedSubfields = getUsedSubfields();
            
            if (usedSubfields.length < availableSubfields.length) {
                const drawButton = document.getElementById('activateDrawingButton');
                drawButton.classList.remove('disable');
                drawButton.onclick = initializePolygonDrawing;
            }

            // Check if all subfields are still used
            checkAllSubfieldsUsed();
        }
    }

    // MAP INTERACTION FUNCTIONS
    function disableClickInteraction() {
        markerMovementEnabled = false;

        if (window.marker) {
            window.marker.clickable = false;
            if (window.marker.element) {
                window.marker.element.style.cursor = 'default';
            }
        }
        if (activePolygon) {
            activePolygon.setOptions({ clickable: true, });
        }
    }

    function enableClickInteraction() {
        markerMovementEnabled = true;

        if (map) {
            map.setOptions({
                draggable: true,
                zoomControl: true,
                scrollwheel: true,
                disableDoubleClickZoom: false
            });
        }

        if (window.marker) {
            window.marker.clickable = true;
            if (window.marker.element) {
                window.marker.element.style.cursor = 'pointer';

            }
            if (activePolygon) {
                activePolygon.setOptions({ clickable: false, });
            }
        }
    }

    // FINISH PHASE POPUP FUNCTIONS
    // Event listener for finish button
    document.getElementById('check')?.addEventListener('click', function (e) {
        e.preventDefault();
        if (!this.classList.contains('next_btn_disable')) {
            showPopupCheck();
        }
    });

    function showPopupCheck() {
        const popupElement = document.getElementById('popup_check');
        if (!popupElement) {
            console.error("Element 'popup_check' not found");
            createPopupCheckDynamically();
            return;
        }

        popupElement.style.display = 'flex';
    }

    function createPopupCheckDynamically() {
        const popupDiv = document.createElement('div');
        popupDiv.id = 'popup_check';
        popupDiv.className = 'popup-check-modal';
        popupDiv.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.5); display: flex; justify-content: center; align-items: center; z-index: 10000;';

        const contentDiv = document.createElement('div');
        contentDiv.className = 'flex flex-col justify-center items-center gap-y-5 popup-content rounded-md sfondo h-[300px] w-[500px] leading-4';

        contentDiv.innerHTML = `
            <h3 class="text-center h3" style="line-height: 110%;">Sei sicuro di voler terminare<br>la prima fase?</h3>
            <p class="text-center p" style="line-height: 110%;">Una volta che procedi alla fase successiva<br>
                non potrai pi√π modificare la posizione.</p>
            <div class="flex gap-x-4 items-center">
                <button id="cancel-popup-check-btn" class="flex gap-x-3 items-center border_button_general">
                    Annulla</button>
                <button id="saveMap" onclick="handleSaveMap()" class="flex gap-x-3 items-center button_general">Conferma 
                    </button>
            </div>
        `;

        popupDiv.appendChild(contentDiv);
        document.body.appendChild(popupDiv);

        document.getElementById('cancel-popup-check-btn').onclick = closePopupCheck;
        document.getElementById('saveMap').onclick = handleSaveMap;

        popupDiv.style.display = 'flex';
    }

    function closePopupCheck() {
        const popupElement = document.getElementById('popup_check');
        if (popupElement) {
            popupElement.style.display = 'none';
        }
    }

    async function handleSaveMap() {
        let lat = def_coordinates.lat
        let lng = def_coordinates.lng

        // Check if marker is in Italy
        if (!checkIfMarkerInItaly(lat, lng)) {
            // If not in Italy, the function will show an alert and we should stop the process
            return;
        }

        // Wait for elevation data before proceeding
        def_altitude = await getElevation(lat, lng)
        savePointData(def_coordinates, def_altitude, addressComponents, full_address)

        try {
            closePopupCheck();

            // Show loading overlay
            const loadingOverlay = document.getElementById('loadingOverlay');
            if (loadingOverlay) {
                loadingOverlay.style.display = 'flex';
            }

            // Check if marker exists
            if (!def_coordinates) {
                showNotification("Per favore inserisci un marker sulla mappa prima di salvare.")
                hideLoadingOverlay();
                return;
            }

            // Set a timeout to ensure we don't get stuck if something goes wrong
            const navigationTimeout = setTimeout(() => {
                changepage();
            }, 200000); // 20 seconds timeout

            // Define Roma coordinates as center for zoom level 5
            const romaCoordinates = { lat: 41.9028, lng: 12.4964 };

            // Capture maps sequentially with explicit promise chaining
            captureMapAtZoom(6, def_coordinates, 1920, 1080, 'mappa_zoom_5.png', false, 0, 6, romaCoordinates)
                .then(() => {
                    return captureMapAtZoom(9, def_coordinates, 1024, 768, 'mappa_zoom_9.png', false, 0, 8);
                })
                .then(() => {
                    return captureMapAtZoom(17, def_coordinates, 1600, 1000, 'mappa_zoom_15.png', true, 200);
                })
                .then(() => {
                    return captureFieldSpecificMaps();
                })
                .then(() => {
                    // Clear the timeout since we completed successfully
                    clearTimeout(navigationTimeout);
                    // Add a delay to ensure all uploads are complete
                    setTimeout(() => {
                        changepage();
                    }, 2000);
                })
                .catch(error => {
                    console.error('Error capturing or uploading maps:', error);
                    // Don't clear the timeout - let it eventually navigate
                    hideLoadingOverlay();
                    alert('Si √® verificato un errore durante il salvataggio delle mappe. Si proceder√† comunque alla fase successiva a breve.');
                });
        } catch (error) {
            console.error('Error during save:', error);
            hideLoadingOverlay();
            alert('Si √® verificato un errore imprevisto. Per favore riprova.');
            // Navigate anyway after a short delay
            setTimeout(changepage, 3000);
        }
    }

    function ensureMapLoaded() {
        return new Promise((resolve) => {
            if (typeof google !== 'undefined' && google.maps && map instanceof google.maps.Map) {
                // Check if map is loaded
                if (map.getDiv().querySelector('img')) {
                    // Map is loaded, add a slight delay to ensure all tiles are rendered
                    setTimeout(() => {
                        resolve();
                    }, 1500);
                } else {
                    // Wait for the 'idle' event
                    google.maps.event.addListenerOnce(map, 'idle', () => {
                        setTimeout(() => {
                            resolve();
                        }, 1500);
                    });

                    // Fallback if event doesn't trigger
                    setTimeout(() => {
                        resolve();
                    }, 5000);
                }
            }
            // Generic fallback for any map library
            else {
                setTimeout(() => {
                    resolve();
                }, 3000);
            }
        });
    }

    // Funzione per calcolare il raggio del cerchio che include tutti i poligoni
    function calculateCircleRadiusForPolygons(width, height) {
        if (polygons.length === 0) {
            return 50; // Raggio di default se non ci sono poligoni
        }

        // Calcola i bounds di tutti i poligoni
        const allBounds = new google.maps.LatLngBounds();
        
        polygons.forEach(p => {
            const path = p.reference.getPath();
            for (let i = 0; i < path.getLength(); i++) {
                allBounds.extend(path.getAt(i));
            }
        });

        // Calcola il centro della mappa
        const mapCenter = map.getCenter();
        
        // Calcola la distanza massima dal centro a qualsiasi punto dei poligoni
        let maxDistance = 0;
        
        polygons.forEach(p => {
            const path = p.reference.getPath();
            for (let i = 0; i < path.getLength(); i++) {
                const point = path.getAt(i);
                const distance = google.maps.geometry.spherical.computeDistanceBetween(mapCenter, point);
                maxDistance = Math.max(maxDistance, distance);
            }
        });

        // Converti la distanza in pixel
        // Usa la scala della mappa per convertire metri in pixel
        const scale = Math.pow(2, map.getZoom());
        const metersPerPixel = 156543.03392 * Math.cos(mapCenter.lat() * Math.PI / 180) / scale;
        
        // Calcola il raggio in pixel con un margine di sicurezza del 20%
        const radiusInPixels = Math.ceil((maxDistance / metersPerPixel) * 1.2);
        
        
        return radiusInPixels;
    }

    // Funzione per ottenere tutti i campi unici dai poligoni
    function getUniqueFields() {
        const fields = new Set();
        polygons.forEach(p => {
            // Estrae la lettera del campo dal nome del sottocampo (es. "A1" -> "A")
            const fieldLetter = p.subfield.charAt(0);
            fields.add(fieldLetter);
        });
        return Array.from(fields).sort();
    }

    // Funzione per ottenere i poligoni di un campo specifico
    function getPolygonsForField(fieldLetter) {
        return polygons.filter(p => p.subfield.charAt(0) === fieldLetter);
    }

    // Funzione per scattare foto specifiche per ogni campo
    async function captureFieldSpecificMaps() {
        if (polygons.length === 0) {
            return Promise.resolve();
        }

        const uniqueFields = getUniqueFields();

        // Cattura sequenzialmente una foto per ogni campo
        let promise = Promise.resolve();
        
        uniqueFields.forEach(fieldLetter => {
            promise = promise.then(() => {
                const filename = `mappa_zoom_20_campo_${fieldLetter}.png`;
                return captureMapAtZoom(20, def_coordinates, 1000, 1000, filename, false, 0, 0, null, fieldLetter);
            });
        });

        return promise;
    }

    // Funzione per calcolare il centro di un poligono
    function calculatePolygonCenter(polygon) {
        const path = polygon.getPath();
        let lat = 0, lng = 0;
        const length = path.getLength();
        
        for (let i = 0; i < length; i++) {
            const point = path.getAt(i);
            lat += point.lat();
            lng += point.lng();
        }
        
        return {
            lat: lat / length,
            lng: lng / length
        };
    }

    // Funzione per convertire coordinate geografiche in pixel sulla mappa
    function latLngToPixel(lat, lng, mapWidth, mapHeight) {
        const scale = Math.pow(2, map.getZoom());
        const projection = map.getProjection();
        
        const point = projection.fromLatLngToPoint(new google.maps.LatLng(lat, lng));
        const mapCenter = projection.fromLatLngToPoint(map.getCenter());
        
        const pixelX = (point.x - mapCenter.x) * scale + mapWidth / 2;
        const pixelY = (point.y - mapCenter.y) * scale + mapHeight / 2;
        
        return { x: pixelX, y: pixelY };
    }

    // Funzione per creare un marker di testo personalizzato per il sottocampo
    function createSubfieldLabel(center, subfieldName) {
        // Crea un elemento HTML per il label
        const labelDiv = document.createElement('div');
        labelDiv.style.cssText = `
            background-color: rgba(255, 255, 255, 0.9);
            border: 2px solid #FF4500;
            border-radius: 6px;
            padding: 4px 8px;
            font-family: Arial, sans-serif;
            font-size: 14px;
            font-weight: bold;
            color: red;
            text-align: center;
            white-space: nowrap;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            pointer-events: none;
            user-select: none;
        `;
        labelDiv.textContent = subfieldName;

        // Crea il marker usando AdvancedMarkerElement
        const labelMarker = new google.maps.marker.AdvancedMarkerElement({
            position: new google.maps.LatLng(center.lat, center.lng),
            map: map,
            content: labelDiv,
            zIndex: 1000
        });

        return labelMarker;
    }

    // Funzione per disegnare le etichette dei sottocampi sui poligoni
    function drawSubfieldLabels(ctx, width, height, specificField) {
        // Determina quali poligoni mostrare
        const visiblePolygons = specificField ? 
            getPolygonsForField(specificField) : 
            polygons.filter(p => p.reference.getVisible());


        visiblePolygons.forEach(polygonData => {
            try {
                // Calcola il centro del poligono
                const center = calculatePolygonCenter(polygonData.reference);
                
                // Converti le coordinate in pixel
                const pixelPos = latLngToPixel(center.lat, center.lng, width, height);
                
                // Verifica che il punto sia all'interno del canvas
                if (pixelPos.x >= 0 && pixelPos.x <= width && pixelPos.y >= 0 && pixelPos.y <= height) {
                    // Configura lo stile del testo
                    ctx.font = 'bold 16px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    
                    // Disegna il contorno del testo (per maggiore leggibilit√†)
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 3;
                    ctx.strokeText(polygonData.subfield, pixelPos.x, pixelPos.y);
                    
                    // Disegna il testo principale
                    ctx.fillStyle = 'red';
                    ctx.fillText(polygonData.subfield, pixelPos.x, pixelPos.y);
                    
                } else {
                    console.warn(`Label "${polygonData.subfield}" is outside canvas bounds: (${pixelPos.x.toFixed(1)}, ${pixelPos.y.toFixed(1)})`);
                }
            } catch (error) {
                console.error(`Error drawing label for polygon ${polygonData.subfield}:`, error);
            }
        });
    }

    async function captureMapAtZoom(zoomLevel, coordinates, width, height, filename, withCircle = false, circleRadiusInPixels = 0, markerRadiusInPixels = 0, centerCoordinates, specificField = null) {
        const originalZoom = map.getZoom();
        const originalCenter = map.getCenter();
        const polygonVisibilityStates = polygons.map(p => ({
            polygon: p.reference,
            visible: p.reference.getVisible() !== false
        }));
        const mapElement = document.getElementById('map');
        const computedStyle = window.getComputedStyle(mapElement);
        const originalWidth = computedStyle.width;
        const originalHeight = computedStyle.height;
        mapElement.style.cssText += `width: ${width}px !important; height: ${height}px !important;`;
        mapElement.offsetHeight;
        let dynamicZoom = zoomLevel;
        let centerPoint = centerCoordinates || coordinates;
        
        if (zoomLevel === 20 && polygons.length > 0) {
            // Gestione specifica per campo se specificField √® fornito
            if (specificField) {
                
                // Nascondi tutti i poligoni e le loro etichette prima
                polygons.forEach(p => {
                    p.reference.setVisible(false);
                    if (p.labelMarker) {
                        p.labelMarker.map = null;
                    }
                });
                
                // Mostra solo i poligoni del campo specifico e le loro etichette
                const fieldPolygons = getPolygonsForField(specificField);
                fieldPolygons.forEach(p => {
                    p.reference.setVisible(true);
                    if (p.labelMarker) {
                        p.labelMarker.map = map;
                    }
                });
                
                
                if (fieldPolygons.length > 0) {
                    // Calcola i bounds solo per i poligoni del campo specifico
                    const bounds = new google.maps.LatLngBounds();
                    fieldPolygons.forEach(p => {
                        const path = p.reference.getPath();
                        for (let i = 0; i < path.getLength(); i++) {
                            bounds.extend(path.getAt(i));
                        }
                    });
                    
                    const extendedBounds = new google.maps.LatLngBounds(
                        new google.maps.LatLng(
                            bounds.getSouthWest().lat() - 0.0003,
                            bounds.getSouthWest().lng() - 0.0003
                        ),
                        new google.maps.LatLng(
                            bounds.getNorthEast().lat() + 0.0003,
                            bounds.getNorthEast().lng() + 0.0003
                        )
                    );
                    centerPoint = extendedBounds.getCenter();
                    map.fitBounds(extendedBounds);
                    await new Promise(resolve => setTimeout(resolve, 500));
                    dynamicZoom = map.getZoom();
                    centerPoint = map.getCenter();
                }
            } else {
                // Logica originale per mostrare tutti i poligoni e le loro etichette
                polygons.forEach(p => {
                    p.reference.setVisible(true);
                    if (p.labelMarker) {
                        p.labelMarker.map = map;
                    }
                });

                // Calculate bounds for all polygons
                const bounds = new google.maps.LatLngBounds();
                polygons.forEach(p => {
                    const path = p.reference.getPath();
                    for (let i = 0; i < path.getLength(); i++) {
                        bounds.extend(path.getAt(i));
                    }
                });
                
                const extendedBounds = new google.maps.LatLngBounds(
                    new google.maps.LatLng(
                        bounds.getSouthWest().lat() - 0.0003,
                        bounds.getSouthWest().lng() - 0.0003
                    ),
                    new google.maps.LatLng(
                        bounds.getNorthEast().lat() + 0.0003,
                        bounds.getNorthEast().lng() + 0.0003
                    )
                );
                centerPoint = extendedBounds.getCenter();
                map.fitBounds(extendedBounds);
                await new Promise(resolve => setTimeout(resolve, 500));
                dynamicZoom = map.getZoom();
                centerPoint = map.getCenter();
            }
        } else {
            // Show/hide polygons and labels based on zoom level
            polygons.forEach(p => {
                const shouldBeVisible = (zoomLevel === 20);
                p.reference.setVisible(shouldBeVisible);
                if (p.labelMarker) {
                    p.labelMarker.map = shouldBeVisible ? map : null;
                }
            });
        }
        // Set the requested zoom level and center coordinates before capturing
        map.setZoom(dynamicZoom);
        // Ensure we use the correct center coordinates based on zoom level
        if (zoomLevel === 6 && centerCoordinates) {
            // For zoom level 6 (world view), use Roma coordinates if provided
            map.setCenter(centerCoordinates);
        } else {
            // For all other zoom levels, use the calculated center or marker coordinates
            map.setCenter(centerPoint);
        }
        
        // Forza lo zoom per il level 17 (ex-15) con controlli aggiuntivi
        if (zoomLevel === 17) {
            let attempts = 0;
            const maxAttempts = 3;
            
            while (map.getZoom() !== 17 && attempts < maxAttempts) {
                attempts++;
                map.setZoom(17);
                await new Promise(resolve => setTimeout(resolve, 1000));
            }
            
        }
        
        // Log actual computed dimensions to verify resize
        const newComputedStyle = window.getComputedStyle(mapElement);
        // Trigger resize event for Google Maps and wait for it to complete
        google.maps.event.trigger(map, 'resize');
        // Add a small delay to ensure the resize is completed and zoom is applied
        await new Promise(resolve => setTimeout(resolve, 5000));
        
        // Nascondi temporaneamente tutti i marker delle etichette durante la cattura
        const labelMarkersToRestore = [];
        if (zoomLevel === 20) {
            polygons.forEach(p => {
                if (p.labelMarker && p.labelMarker.map) {
                    labelMarkersToRestore.push(p.labelMarker);
                    p.labelMarker.map = null;
                }
            });
            // Aspetta un momento per assicurarsi che i marker siano nascosti
            await new Promise(resolve => setTimeout(resolve, 500));
        }
        
        try {
            // Use html2canvas to capture the map
            const canvas = await html2canvas(mapElement, {
                useCORS: true,
                allowTaint: true,
                width: width,
                height: height,
                scale: 1,
                logging: false,
                imageTimeout: 300000
            });

            // Create our own canvas for customizations
            const finalCanvas = document.createElement('canvas');
            finalCanvas.width = width;
            finalCanvas.height = height;
            const finalCtx = finalCanvas.getContext('2d');
            finalCtx.drawImage(canvas, 0, 0, width, height);

            // Add markers or circles if needed (for non-detailed views)
            if (zoomLevel !== 20) {
                if (withCircle && circleRadiusInPixels > 0) {
                    // Per lo zoom level 17 (ex-15), calcola il raggio dinamicamente basandosi sui poligoni
                    let actualRadius = circleRadiusInPixels;
                    if (zoomLevel === 17 && polygons.length > 0) {
                        // Rendi visibili i poligoni temporaneamente per il calcolo
                        polygons.forEach(p => {
                            p.reference.setVisible(true);
                        });
                        actualRadius = calculateCircleRadiusForPolygons(width, height);
                    } else if (zoomLevel === 17) {
                        // Se non ci sono poligoni, usa un raggio pi√π grande per lo zoom 17
                        actualRadius = 200; // Aumentato da 50 a 200 pixel
                    }
                    
                    // Draw a yellow circle for zoom level 17 (ex-15)
                    finalCtx.strokeStyle = 'yellow';
                    finalCtx.lineWidth = 3;
                    finalCtx.beginPath();
                    finalCtx.arc(width / 2, height / 2, actualRadius, 0, Math.PI * 2, false);
                    finalCtx.stroke();
                } else {
                    // Draw a red dot for zoom levels 5 and 9
                    finalCtx.fillStyle = 'red';
                    finalCtx.beginPath();
                    
                    if (zoomLevel === 6) {
                        // For zoom level 6, calculate the pixel position of the actual coordinates
                        const scale = Math.pow(2, map.getZoom());
                        const projection = map.getProjection();
                        const actualPoint = projection.fromLatLngToPoint(new google.maps.LatLng(coordinates.lat, coordinates.lng));
                        const centerPoint = projection.fromLatLngToPoint(map.getCenter());
                        
                        // Calculate pixel offset from center
                        const pixelX = (actualPoint.x - centerPoint.x) * scale + width / 2;
                        const pixelY = (actualPoint.y - centerPoint.y) * scale + height / 2;
                        
                        const adjustedMarkerRadius = markerRadiusInPixels;
                        finalCtx.arc(pixelX, pixelY, adjustedMarkerRadius, 0, Math.PI * 2, true);
                    } else {
                        // For other zoom levels, keep the dot in the center
                        const adjustedMarkerRadius = zoomLevel === 9 ? markerRadiusInPixels * 2 : markerRadiusInPixels;
                        finalCtx.arc(width / 2, height / 2, adjustedMarkerRadius, 0, Math.PI * 2, true);
                    }
                    finalCtx.fill();
                }
            } else {
                // Per lo zoom level 20, aggiungi le etichette dei sottocampi
                drawSubfieldLabels(finalCtx, width, height, specificField);
            }

            // Upload the canvas to server
            await uploadCanvasToServer(finalCanvas, filename);

            // Restore original map settings
            map.setZoom(originalZoom);
            map.setCenter(originalCenter);

            // Restore original dimensions
            mapElement.style.width = originalWidth;
            mapElement.style.height = originalHeight;

            // Restore original polygon visibility states
            polygonVisibilityStates.forEach((state, index) => {
                state.polygon.setVisible(state.visible);
            });
            
            // Restore label markers that were hidden during capture
            if (zoomLevel === 20) {
                labelMarkersToRestore.forEach(marker => {
                    marker.map = map;
                });
            }
            
            // Restore label markers visibility based on polygon visibility
            polygons.forEach((p, index) => {
                if (p.labelMarker) {
                    const shouldShowLabel = p.reference.getVisible();
                    p.labelMarker.map = shouldShowLabel ? map : null;
                }
            });

            // Trigger resize event again to ensure proper display
            google.maps.event.trigger(map, 'resize');

            return finalCanvas;
        } catch (error) {
            console.error("Error capturing map:", error);

            // Ensure we restore the map even if there's an error
            map.setZoom(originalZoom);
            map.setCenter(originalCenter);
            mapElement.style.width = originalWidth;
            mapElement.style.height = originalHeight;

            // Restore original polygon visibility states even on error
            polygonVisibilityStates.forEach((state, index) => {
                state.polygon.setVisible(state.visible);
            });
            
            // Restore label markers that were hidden during capture even on error
            if (zoomLevel === 20) {
                labelMarkersToRestore.forEach(marker => {
                    marker.map = map;
                });
            }
            
            // Restore label markers visibility based on polygon visibility even on error
            polygons.forEach((p, index) => {
                if (p.labelMarker) {
                    const shouldShowLabel = p.reference.getVisible();
                    p.labelMarker.map = shouldShowLabel ? map : null;
                }
            });

            google.maps.event.trigger(map, 'resize');

            throw error;
        }
    }

    function uploadCanvasToServer(canvas, filename) {
        return new Promise((resolve, reject) => {
            // Ensure save_map_array is initialized
            if (!save_map_array) {
                save_map_array = [];
            }

            canvas.toBlob(function (blob) {
                const formData = new FormData();
                const csrftoken = document.querySelector('[name=csrfmiddlewaretoken]').value;
                formData.append('image', blob, filename);
                // Effettua la richiesta POST al server per salvare l'immagine
                fetch('/upload_image/', {
                    method: 'POST',
                    body: formData,
                    headers: {
                        'X-CSRFToken': csrftoken  // Token CSRF per protezione
                    }
                })
                    .then(response => response.json())
                    .then(data => {
                        if (data.success) {
                            save_map = true;
                            save_map_array.push(save_map);
                            resolve(true);
                        } else {
                            console.error('Errore nel caricamento dell\'immagine:', data.error);
                            reject(data.error);
                        }
                    })
                    .catch(error => {
                        console.error('Errore:', error);
                        reject(error);
                    });
            }, 'image/png');
        });
    }

    function hideLoadingOverlay() {
        const loadingOverlay = document.getElementById('loadingOverlay');
        if (loadingOverlay) {
            loadingOverlay.style.display = 'none';
        }
    }

    function showLoadingOverlay() {
        const loadingOverlay = document.getElementById('loadingOverlay');
        if (loadingOverlay) {
            loadingOverlay.style.display = 'flex';
        }
    }

    function changepage() {
        showLoadingOverlay();

        saveAllPolygons().then(success => {
            // Ensure we have a valid array, even if empty
            if (!save_map_array) {
                save_map_array = [];
            }

            window.location.href = '/project/dove';
        }).catch(error => {
            console.error("Error saving polygons:", error);
            hideLoadingOverlay();
            alert("Si √® verificato un errore durante il salvataggio dei poligoni. Per favore riprova.");
        });
    }


    // Implement proper saveAllPolygons function 
    function saveAllPolygons() {
        return new Promise((resolve, reject) => {
            // If we have polygons to save
            if (polygons && polygons.length > 0) {

                // Organize polygons by subfield
                const polygonsBySubfield = {};

                polygons.forEach(p => {
                    const path = p.reference.getPath();
                    const coordinates = [];

                    for (let i = 0; i < path.getLength(); i++) {
                        const point = path.getAt(i);
                        coordinates.push({
                            lat: point.lat(),
                            lng: point.lng()
                        });
                    }

                    // Create a GeoJSON polygon for turf.js
                    const turfPolygon = {
                        type: 'Feature',
                        properties: {},
                        geometry: {
                            type: 'Polygon',
                            coordinates: [[
                                // Turf.js expects coordinates as [lng, lat], not [lat, lng]
                                ...coordinates.map(coord => [coord.lng, coord.lat]),
                                // Close the polygon by repeating the first coordinate
                                [coordinates[0].lng, coordinates[0].lat]
                            ]]
                        }
                    };

                    // Calculate area in square meters
                    const areaPolygon = turf.area(turfPolygon);

                    // Create polygon data
                    const polygonData = {
                        id: p.id,
                        name: p.name,
                        coordinates: coordinates,
                        area: areaPolygon
                    };

                    // Add to subfield object
                    if (!polygonsBySubfield[p.subfield]) {
                        polygonsBySubfield[p.subfield] = polygonData;
                    }
                });

                // Make API call to save polygons
                const csrftoken = document.querySelector('[name=csrfmiddlewaretoken]').value;
                fetch('/update_polygon/', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': csrftoken
                    },
                    body: JSON.stringify({
                        'polygons_by_subfield': polygonsBySubfield,
                        'project_code': window.project_code || 0
                    })
                })
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'success' && data.message) {
                        resolve(true);
                    } else {
                        console.error('Error saving polygons:', data);
                        resolve(false);
                    }
                })
                .catch(error => {
                    console.error('Error during polygon save:', error);
                    // Resolve instead of reject to prevent blocking the page transition
                    resolve(false);
                });
            } else {
                resolve(true);
            }
        });
    }


    //funzione per salvare in sessine lat,lng,alt,indirizzo
    function savePointData(coordinates, altitude, addresscomponent, fulladdress) {
        let lat = coordinates.lat
        let lng = coordinates.lng
        const csrftoken = document.querySelector('[name=csrfmiddlewaretoken]').value;

        // First ensure we have address data by calling reverseGeocode without await
        reverseGeocode(lat, lng).then(() => {
            // Then submit the data
            fetch('/update_session/', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/x-www-form-urlencoded',
                    'X-CSRFToken': csrftoken
                },
                body: new URLSearchParams({
                    'latitude': lat,
                    'longitude': lng,
                    'altitude': altitude,
                    'address': fulladdress,
                    'address_component': JSON.stringify(addresscomponent),
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.message) {
                    const next_arrow_1 = document.getElementById('next_arrow_1');
                    
                    next_arrow_1.classList.remove('next_btn_disable')
                } else {
                    console.error(data.error);
                }
            }).catch(error => console.error('Error:', error));
        }).catch(error => console.error('Error in reverse geocoding:', error));
    }

    function checkIfMarkerInItaly(lat, lng) {
        // Italy's approximate bounding box
        const italyBounds = {
            north: 47.1,   // Northern border
            south: 35.4,   // Southern border (includes Sicily)
            west: 6.6,     // Western border
            east: 19    // Eastern border
        };
        
        // Check if coordinates are within Italy's bounds
        if (lat >= italyBounds.south && lat <= italyBounds.north && 
            lng >= italyBounds.west && lng <= italyBounds.east) {
            return true;
        } else {
            // Show alert for addresses outside Italy
            showNotification("Indirizzo non disponibile. L'indirizzo deve essere in Italia.")
            return false;
        }
    }

    // Function to get used subfields
    function getUsedSubfields() {
        const used = polygons.map(function(p) { return p.subfield; });
        return used;
    }

    // Function to update available subfields in select
    function updateSubfieldSelect() {
        const subfieldSelect = document.getElementById('subfield-select');
        if (!subfieldSelect) {
            console.error("Subfield select element not found");
            return;
        }

        const usedSubfields = getUsedSubfields();
        
        // Clear current options
        subfieldSelect.innerHTML = '<option value="">Seleziona un sottocampo</option>';
        
        // Add only unused subfields
        availableSubfields.forEach(function(subfield) {
            if (!usedSubfields.includes(subfield)) {
                const option = document.createElement('option');
                option.value = subfield;
                option.textContent = subfield;
                subfieldSelect.appendChild(option);
            }
        });

        // If no more subfields available, disable drawing
        if (usedSubfields.length >= availableSubfields.length) {
            const drawButton = document.getElementById('activateDrawingButton');
            drawButton.classList.add('opacity-75');

        }
    }

    // Funzione per calcolare la distanza minima tra due poligoni
    function calcolaDistanzaMinimaTraPoligoni(poligono1, poligono2) {
        const path1 = poligono1.getPath();
        const path2 = poligono2.getPath();
        let distanzaMinima = Infinity;
        
        // Confronta ogni vertice del primo poligono con ogni vertice del secondo
        for (let i = 0; i < path1.getLength(); i++) {
            const vertice1 = path1.getAt(i);
            for (let j = 0; j < path2.getLength(); j++) {
                const vertice2 = path2.getAt(j);
                const distanza = google.maps.geometry.spherical.computeDistanceBetween(vertice1, vertice2);
                if (distanza < distanzaMinima) {
                    distanzaMinima = distanza;
                }
            }
        }
        
        return distanzaMinima;
    }

</script>

<style>
    /* Animation Classes */
    .slide-out-left {
        animation: slideOutLeft 0.2s forwards;
    }

    .slide-in-left {
        animation: slideInLeft 0.2s forwards;
    }

    .slide-out-right {
        animation: slideOutRight 0.2s forwards;
    }

    .slide-in-right {
        animation: slideInRight 0.2s forwards;
    }

    /* Animation Keyframes */
    @keyframes slideOutLeft {
        from {
            transform: translateX(0);
        }

        to {
            transform: translateX(-100%);
        }
    }

    @keyframes slideInLeft {
        from {
            transform: translateX(100%);
        }

        to {
            transform: translateX(0);
        }
    }

    @keyframes slideOutRight {
        from {
            transform: translateX(0);
        }

        to {
            transform: translateX(100%);
        }
    }

    @keyframes slideInRight {
        from {
            transform: translateX(-100%);
        }

        to {
            transform: translateX(0);
        }
    }

    @keyframes l8-1 {
        100% {
            transform: translateX(25px);
        }
    }

    @keyframes l8-2 {
        100% {
            transform: rotate(-180deg) translateX(25px);
        }
    }

    /* Map Container Styles */
    .map-container {
        width: 100% !important;
        height: 100% !important;
        min-height: 100% !important;
        position: relative !important;
        overflow: hidden !important;
    }

    /* Ensure Google Map fills the container */
    .gm-style {
        width: 100% !important;
        height: 100% !important;
    }

    /* Make sure all map tiles load properly */
    .gm-style img {
        max-width: none !important;
        max-height: none !important;
    }

    /* Force map to be properly sized on mobile */
    @media (max-width: 768px) {
        .map-container {
            height: 400px !important;
            min-height: 400px !important;
        }
    }

    /* Loader Styles */
    #loadingOverlay {
        position: absolute;
        top: 0;
        left: 0;
        padding-top: 200px;
        width: 100%;
        height: 100%;
        background-color: rgb(0, 0, 0);
        display: none;
        flex-direction: column;
        gap: 40px;
        justify-content: start;
        align-items: center;
        z-index: 9999;
    }
    
    .loader {
    width: 15px;
    aspect-ratio: 1;
    position: relative;
    color: #fff;
    }
    
    .loader::before,
    .loader::after {
    content: "";
    position: absolute;
    inset: 0;
    border-radius: 50%;
    background: #fff;
    }
    .loader::before {
    box-shadow: -25px 0;
    animation: l8-1 1s infinite linear;
    }
    .loader::after {
    transform: rotate(0deg) translateX(25px);
    animation: l8-2 1s infinite linear;
    }

    @keyframes l8-1 {
        100%{transform: translateX(25px)}
    }
    @keyframes l8-2 {
        100%{transform: rotate(-180deg) translateX(25px)}
    }

    /* Drawing Styles */
    .active_draw rect {
        fill: #FFE182;
    }

    .active_draw path {
        fill: #EFB90B;
    }

    /* Disabled Element Styles */
    .disable {
        cursor: not-allowed !important;
        opacity: 0.5;
        pointer-events: auto !important;
    }

    .disable rect {
        fill: #a57f01 !important;
    }

    .disable path {
        fill: #6e5501 !important;
    }
    .invert{
        filter: invert(1);
    }
</style>
{% endblock %}